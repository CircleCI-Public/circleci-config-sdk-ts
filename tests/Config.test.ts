import * as YAML from 'yaml';
import * as CircleCI from '../src/index';
import { GenerableType } from '../src/lib/Config/exports/Mapping';
import {
  parseGenerable,
  setLogParsing,
} from '../src/lib/Config/exports/Parsing';
import { version as SDKVersion } from '../src/package-version.json';

describe('Generate a Setup workflow config', () => {
  const myConfig = new CircleCI.Config(true).generate();
  it('Should produce a blank config with Setup set to true', () => {
    const expected = {
      version: 2.1,
      setup: true,
      jobs: {},
      workflows: {},
    };
    expect(YAML.parse(myConfig)).toEqual(expected);
  });
  it('Should include the version comment string', () => {
    const comment = `# This configuration has been automatically generated by the CircleCI Config SDK.
# For more information, see https://github.com/CircleCI-Public/circleci-config-sdk-ts
# SDK Version: ${SDKVersion}
`;
    expect(myConfig).toContain(comment);
  });
});

describe('Generate a config with parameters', () => {
  const myConfig = new CircleCI.Config(true);

  myConfig.defineParameter('greeting', 'string', 'hello world');

  const configResult = myConfig.generate();

  it('Should produce a blank config with parameters', () => {
    const expected = {
      version: 2.1,
      setup: true,
      parameters: {
        greeting: {
          type: 'string',
          default: 'hello world',
        },
      },
      jobs: {},
      workflows: {},
    };
    expect(YAML.parse(configResult)).toEqual(expected);
  });
  it('Should include the version comment string', () => {
    const comment = `# This configuration has been automatically generated by the CircleCI Config SDK.
# For more information, see https://github.com/CircleCI-Public/circleci-config-sdk-ts
# SDK Version: ${SDKVersion}
`;
    expect(configResult).toContain(comment);
  });
});

describe('Parse a fully complete config', () => {
  const myConfig = new CircleCI.Config();

  myConfig.defineParameter('greeting', 'string', 'hello world!');

  const docker = new CircleCI.executors.DockerExecutor(
    'cimg/node:<< parameters.version >>',
  );
  const reusableDocker = new CircleCI.reusable.ReusableExecutor(
    'docker',
    docker,
  );

  reusableDocker.defineParameter('version', 'string', '16.3');
  myConfig.addReusableExecutor(reusableDocker);

  const customCommand = new CircleCI.reusable.CustomCommand(
    'say_hello',
    [
      new CircleCI.commands.Run({
        command: 'echo << parameters.greeting >>',
      }),
    ],
    new CircleCI.parameters.CustomParametersList([
      new CircleCI.parameters.CustomParameter('greeting', 'string'),
    ]),
  );

  myConfig.addCustomCommand(customCommand);

  const jobA = new CircleCI.Job('my-job-A', reusableDocker.reuse(), [
    new CircleCI.reusable.ReusableCommand(customCommand, {
      greeting: '<< pipeline.parameters.greeting >>',
    }),
  ]);
  const jobB = new CircleCI.Job('my-job-B', reusableDocker.reuse(), [
    new CircleCI.reusable.ReusableCommand(customCommand, {
      greeting: 'sup world!',
    }),
  ]);

  myConfig.addJob(jobA);
  myConfig.addJob(jobB);

  const myWorkflow = new CircleCI.Workflow('my-workflow');

  myWorkflow.addJob(jobA);
  myWorkflow.addJob(jobB, { requires: [jobA.name] });

  myConfig.addWorkflow(myWorkflow);

  const configResult = {
    version: 2.1,
    setup: false,
    commands: {
      say_hello: {
        parameters: {
          greeting: {
            type: 'string',
          },
        },
        steps: [
          {
            run: {
              command: 'echo << parameters.greeting >>',
            },
          },
        ],
      },
    },
    parameters: {
      greeting: {
        type: 'string',
        default: 'hello world!',
      },
    },
    executors: {
      docker: {
        docker: [{ image: 'cimg/node:<< parameters.version >>' }],
        parameters: {
          version: {
            type: 'string',
            default: '16.3',
          },
        },
      },
    },
    jobs: {
      'my-job-A': {
        executor: 'docker',
        steps: [
          {
            say_hello: {
              greeting: '<< pipeline.parameters.greeting >>',
            },
          },
        ],
      },
      'my-job-B': {
        executor: 'docker',
        steps: [
          {
            say_hello: {
              greeting: 'sup world!',
            },
          },
        ],
      },
    },
    workflows: {
      'my-workflow': {
        jobs: [{ 'my-job-A': {} }, { 'my-job-B': { requires: ['my-job-A'] } }],
      },
    },
  };

  it('Should produce a blank config with parameters', () => {
    expect(CircleCI.parsers.parseConfig(configResult)).toEqual(myConfig);
  });

  it('Should be fully circular', () => {
    setLogParsing(true);
    expect(
      CircleCI.parsers.parseConfig(YAML.parse(myConfig.generate())),
    ).toEqual(myConfig);
    setLogParsing(false);
  });

  it('Should be fully circular and parsable as string', () => {
    expect(CircleCI.parsers.parseConfig(myConfig.generate())).toEqual(myConfig);
  });

  it('Should have the correct static properties', () => {
    expect(myConfig.generableType).toBe(CircleCI.mapping.GenerableType.CONFIG);
  });

  it('Should throw error when parsing returns undefined', () => {
    expect(() => {
      parseGenerable(GenerableType.CONFIG, configResult, () => undefined);
    }).toThrowError();
  });
});
