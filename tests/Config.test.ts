import * as YAML from 'yaml';
import * as CircleCI from '../src/index';
import { version as SDKVersion } from '../package-version.json';
import fs from 'fs';

describe('Generate a Setup workflow config', () => {
  const myConfig = new CircleCI.Config(true).stringify();
  it('Should produce a blank config with Setup set to true', () => {
    const expected = {
      version: 2.1,
      setup: true,
      jobs: {},
      workflows: {},
    };
    expect(YAML.parse(myConfig)).toEqual(expected);
  });
  it('Should include the version comment string', () => {
    const comment = `# This configuration has been automatically generated by the CircleCI Config SDK.
# For more information, see https://github.com/CircleCI-Public/circleci-config-sdk-ts
# SDK Version: ${SDKVersion}
`;
    expect(myConfig).toContain(comment);
  });
});

describe('Generate a config with parameters', () => {
  const myConfig = new CircleCI.Config(true);

  myConfig.defineParameter('greeting', 'string', 'hello world');

  const configResult = myConfig.stringify();

  it('Should produce a blank config with parameters', () => {
    const expected = {
      version: 2.1,
      setup: true,
      parameters: {
        greeting: {
          type: 'string',
          default: 'hello world',
        },
      },
      jobs: {},
      workflows: {},
    };
    expect(YAML.parse(configResult)).toEqual(expected);
  });

  it('Should include the version comment string', () => {
    const comment = `# This configuration has been automatically generated by the CircleCI Config SDK.
# For more information, see https://github.com/CircleCI-Public/circleci-config-sdk-ts
# SDK Version: ${SDKVersion}
`;
    expect(configResult).toContain(comment);
  });
});

describe('Parse a fully complete config', () => {
  const myConfig = new CircleCI.Config();

  myConfig.defineParameter('greeting', 'string', 'hello world!');

  const docker = new CircleCI.executors.DockerExecutor(
    'cimg/node:<< parameters.version >>',
  );
  const reusableDocker = new CircleCI.reusable.ReusableExecutor(
    'docker',
    docker,
  );

  reusableDocker.defineParameter('version', 'string', '16.3');
  myConfig.addReusableExecutor(reusableDocker);

  const reusableCommand = new CircleCI.reusable.ReusableCommand(
    'say_hello',
    [
      new CircleCI.commands.Run({
        command: 'echo << parameters.greeting >>',
      }),
    ],
    new CircleCI.parameters.CustomParametersList([
      new CircleCI.parameters.CustomParameter('greeting', 'string'),
    ]),
  );

  myConfig.addReusableCommand(reusableCommand);

  const jobA = new CircleCI.Job(
    'my-job-A',
    reusableDocker.reuse({ version: '17.2' }),
    [
      new CircleCI.reusable.ReusedCommand(reusableCommand, {
        greeting: '<< pipeline.parameters.greeting >>',
      }),
    ],
  );
  const jobB = new CircleCI.Job('my-job-B', reusableDocker.reuse(), [
    new CircleCI.reusable.ReusedCommand(reusableCommand, {
      greeting: 'sup world!',
    }),
  ]);

  myConfig.addJob(jobA);
  myConfig.addJob(jobB);

  const myWorkflow = new CircleCI.Workflow('my-workflow');

  myWorkflow.addJob(jobA);
  myWorkflow.addJob(jobB, { requires: [jobA.name] });

  myConfig.addWorkflow(myWorkflow);

  it('Should have the correct static properties', () => {
    expect(myConfig.generableType).toBe(CircleCI.mapping.GenerableType.CONFIG);
  });
});

describe('Save config to file in Node environment', () => {
  const myConfig = new CircleCI.Config();
  const executor = new CircleCI.executors.DockerExecutor('cimg/node:16.3');
  const job = new CircleCI.Job('my-job', executor, [
    new CircleCI.commands.Run({ command: 'echo hello world' }),
  ]);
  myConfig.addJob(job);
  const myWorkflow = new CircleCI.Workflow('my-workflow');
  myWorkflow.addJob(job);
  myConfig.addWorkflow(myWorkflow);
  myConfig.writeFile('/tmp/test-config.yml');
  it('Should write a file to the specified path', () => {
    expect(fs.existsSync('/tmp/test-config.yml')).toBe(true);
  });
});

afterAll(() => {
  fs.rmSync('/tmp/test-config.yml');
});
